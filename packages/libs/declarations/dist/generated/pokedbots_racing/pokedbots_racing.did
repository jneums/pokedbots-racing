type UpgradeFinishedResult = 
 variant {
   Failed: record {
             nat;
             text;
           };
   InProgress: nat;
   Success: nat;
 };
type TrendDirection = 
 variant {
   Down: nat;
   New;
   Stable;
   Up: nat;
 };
type TreasuryError = 
 variant {
   LedgerTrap: text;
   NotOwner;
   TransferFailed: TransferError;
 };
type TransferError = 
 variant {
   BadBurn: record {min_burn_amount: nat;};
   BadFee: record {expected_fee: nat;};
   CreatedInFuture: record {ledger_time: Timestamp;};
   Duplicate: record {duplicate_of: nat;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: nat;};
   TemporarilyUnavailable;
   TooOld;
 };
type TraitValue = 
 record {
   id: nat;
   name: text;
 };
type TraitSchema = vec Trait;
type Trait = 
 record {
   id: nat;
   name: text;
   values: vec TraitValue;
 };
type Timestamp = nat64;
type TimerId = nat;
type TimerDiagnostics = 
 record {
   currentTime: Time__1;
   lastExecutionDelta: int;
   lockStatus: opt Time__1;
   nextExecutionDelta: opt int;
   overdueActions: nat;
   pendingActions: nat;
   systemTimerStatus: opt TimerId;
   totalActions: nat;
 };
type Time__1 = nat;
type Time = int;
type Terrain = 
 variant {
   MetalRoads;
   ScrapHeaps;
   WastelandSand;
 };
type Subaccount = blob;
type StreamingToken = blob;
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: StreamingCallback;
                              token: StreamingToken;
                            };};
type StreamingCallbackResponse = 
 record {
   body: blob;
   token: opt StreamingToken;
 };
type StreamingCallback = func (StreamingToken) ->
                          (opt StreamingCallbackResponse) query;
type Sponsor = 
 record {
   amount: nat;
   message: opt text;
   sponsor: principal;
   timestamp: int;
 };
type ScheduledEvent = 
 record {
   createdAt: int;
   eventId: nat;
   eventType: EventType;
   metadata: EventMetadata;
   raceIds: vec nat;
   registrationCloses: int;
   registrationOpens: int;
   scheduledTime: int;
   status: EventStatus;
 };
type Result_2 = 
 variant {
   err: TreasuryError;
   ok;
 };
type Result_1 = 
 variant {
   err: text;
   ok;
 };
type Result = 
 variant {
   err: TreasuryError;
   ok: nat;
 };
type ReconstitutionTrace = 
 record {
   actionsRestored: nat;
   errors: vec text;
   migratedFrom: text;
   migratedTo: text;
   timersRestored: nat;
   timestamp: Time__1;
   validationPassed: bool;
 };
type RaceStatus = 
 variant {
   Cancelled;
   Completed;
   InProgress;
   Upcoming;
 };
type RaceResult = 
 record {
   finalTime: float64;
   nftId: text;
   owner: principal;
   position: nat;
   prizeAmount: nat;
 };
type RaceEntry = 
 record {
   enteredAt: int;
   entryFee: nat;
   nftId: text;
   owner: principal;
 };
type RaceClass = 
 variant {
   Elite;
   Raider;
   Scavenger;
   SilentKlan;
 };
type Race = 
 record {
   createdAt: int;
   distance: nat;
   duration: nat;
   entries: vec RaceEntry;
   entryDeadline: int;
   entryFee: nat;
   maxEntries: nat;
   minEntries: nat;
   name: text;
   platformBonus: nat;
   platformTax: nat;
   prizePool: nat;
   raceClass: RaceClass;
   raceId: nat;
   results: opt vec RaceResult;
   sponsors: vec Sponsor;
   startTime: int;
   status: RaceStatus;
   terrain: Terrain;
 };
type NFTStats = vec nat;
type NFTMetadata = 
 vec record {
       text;
       text;
     };
type McpServer = 
 service {
   cancel_actions_by_filter: (filter: ActionFilter) -> (CancellationResult);
   cancel_actions_by_ids: (ids: vec nat) -> (CancellationResult);
   cancel_races_by_ids: (raceIds: vec nat) -> (vec record {
                                                     nat;
                                                     text;
                                                   });
   clear_event_race_ids: () -> (text);
   clear_reconstitution_traces: () -> ();
   /// * Creates a new API key. This API key is linked to the caller's principal.
   ///    * @param name A human-readable name for the key.
   ///    * @returns The raw, unhashed API key. THIS IS THE ONLY TIME IT WILL BE VISIBLE.
   create_my_api_key: (name: text, scopes: vec text) -> (text);
   /// Debug method to check ownership verification
   debug_check_bot_owner: (tokenIndex: nat32, userPrincipal: principal) ->
    (record {
       extCanister: text;
       garageAccountId: text;
       ownerResult: text;
       tokenIdentifier: text;
     });
   debug_create_test_race: (startInMinutes: nat) -> (text);
   /// Debug: Preview what stats would be derived for a token index
   /// Shows both metadata-based and fallback stats for comparison
   debug_preview_stats: (tokenIndex: nat) ->
    (record {
       currentStoredStats:
        opt
         record {
           acceleration: nat;
           accelerationBonus: nat;
           baseAcceleration: nat;
           basePowerCore: nat;
           baseSpeed: nat;
           baseStability: nat;
           faction: text;
           powerCore: nat;
           powerCoreBonus: nat;
           speed: nat;
           speedBonus: nat;
           stability: nat;
           stabilityBonus: nat;
         };
       hasPrecomputedStats: bool;
       precomputedStats:
        opt
         record {
           acceleration: nat;
           faction: text;
           powerCore: nat;
           speed: nat;
           stability: nat;
         };
     }) query;
   debug_seed_leaderboard: (count: nat) -> (text);
   /// Decode EXT token identifier to get token index (public query)
   decode_token_identifier: (tokenIdentifier: text) -> (nat) query;
   delete_events_after: (afterEventId: nat) -> (text);
   delete_events_and_races: (eventIds: vec nat) -> (text);
   delete_orphaned_races: () -> (text);
   emergency_clear_all_timers: () -> (nat);
   /// Encode token index to EXT token identifier (public query)
   encode_token_identifier: (tokenIndex: nat32) -> (text) query;
   force_finish_race: (raceId: nat) -> (text);
   force_release_lock: () -> (opt Time);
   force_system_timer_cancel: () -> (bool);
   get_actions_by_filter: (filter: ActionFilter) -> (vec ActionDetail) query;
   get_all_scheduled_events: () -> (vec ScheduledEvent) query;
   /// Get all token IDs that have metadata
   get_all_token_ids: () -> (vec nat) query;
   /// Get a specific pre-computed base stat
   get_base_stat: (tokenId: nat) ->
    (opt
      record {
        acceleration: nat;
        faction: text;
        powerCore: nat;
        speed: nat;
        stability: nat;
      }) query;
   /// Get total count of pre-computed base stats
   get_base_stats_count: () -> (nat) query;
   /// Get public bot profile (stats + career, no sensitive info like battery/condition)
   get_bot_profile: (tokenIndex: nat) ->
    (opt
      record {
        career:
         record {
           podiums: nat;
           racesEntered: nat;
           totalEarnings: nat;
           wins: nat;
         };
        eloRating: nat;
        faction: FactionType;
        isInitialized: bool;
        name: opt text;
        owner: opt principal;
        raceClass: RaceClass;
        stats:
         record {
           acceleration: nat;
           overallRating: nat;
           powerCore: nat;
           speed: nat;
           stability: nat;
         };
        tokenIndex: nat;
      }) query;
   get_bot_race_history: (tokenIndex: nat, limit: nat, afterRaceId:
    opt nat) ->
    (record {
       hasMore: bool;
       nextRaceId: opt nat;
       races:
        vec
         record {
           eventId: nat;
           eventName: text;
           finalTime: opt float64;
           position: nat;
           prizeAmount: nat;
           raceId: nat;
           raceName: text;
           scheduledTime: int;
           totalRacers: nat;
         };
     }) query;
   get_current_periods: () -> (record {
                                 monthId: nat;
                                 seasonId: nat;
                               }) query;
   get_event_details: (eventId: nat) -> (opt ScheduledEvent) query;
   get_event_with_races: (eventId: nat) ->
    (opt
      record {
        event: ScheduledEvent;
        races:
         vec
          record {
            currentEntries: nat;
            distance: nat;
            entryFee: nat;
            maxEntries: nat;
            name: text;
            participantTokens: vec nat;
            raceClass: RaceClass;
            raceId: nat;
            terrain: Terrain;
          };
      }) query;
   /// Get the currently configured EXT NFT canister ID.
   get_ext_canister: () -> (principal) query;
   /// Get the garage account ID for a given user principal
   /// This is useful for testing and external tools that need to know where to send NFTs
   get_garage_account_id: (userPrincipal: principal) -> (text) query;
   /// Get the currently configured ICP ledger canister ID.
   get_icp_ledger: () -> (opt principal) query;
   get_latest_reconstitution_trace: () -> (opt ReconstitutionTrace) query;
   get_leaderboard: (lbType: LeaderboardType, limit: nat) ->
    (vec LeaderboardEntry) query;
   get_my_ranking: (lbType: LeaderboardType, tokenIndex: nat) ->
    (opt LeaderboardEntry) query;
   /// Get decoded metadata for a specific NFT (public query)
   get_nft_metadata: (tokenId: nat) -> (opt NFTMetadata) query;
   /// Get decoded metadata for multiple NFTs in one call (public query)
   get_nft_metadata_batch: (tokenIds: vec nat) ->
    (vec record {
           nat;
           opt NFTMetadata;
         }) query;
   /// Get metadata by EXT token identifier (public query)
   get_nft_metadata_by_identifier: (tokenIdentifier: text) ->
    (opt NFTMetadata) query;
   /// Get paginated NFT metadata (decoded, public query)
   get_nft_metadata_page: (offset: nat, limit: nat) ->
    (vec record {
           nat;
           NFTMetadata;
         }) query;
   /// Get raw stats for a specific NFT (returns integer array)
   get_nft_stats: (tokenId: nat) -> (opt NFTStats) query;
   /// Get raw stats by EXT token identifier (public query)
   get_nft_stats_by_identifier: (tokenIdentifier: text) ->
    (opt NFTStats) query;
   /// Get a decoded trait value by trait name (for display)
   get_nft_trait: (tokenId: nat, traitName: text) -> (opt text) query;
   /// Get a specific trait value ID by trait index (for calculations)
   get_nft_trait_value: (tokenId: nat, traitIndex: nat) -> (opt nat) query;
   /// Get the current owner of the canister.
   get_owner: () -> (principal) query;
   get_past_events: (offset: nat, limit: nat) -> (vec ScheduledEvent) query;
   get_race_by_id: (raceId: nat) -> (opt Race) query;
   get_reconstitution_traces: () -> (vec ReconstitutionTrace) query;
   /// Find all races that are not associated with any event
   /// Useful for finding standalone races created outside the event system
   get_standalone_races: () ->
    (vec
      record {
        entries: nat;
        name: text;
        raceClass: RaceClass;
        raceId: nat;
        startTime: int;
        status: RaceStatus;
      }) query;
   get_timer_diagnostics: () -> (TimerDiagnostics) query;
   /// Get total count of NFTs with metadata stored
   get_total_nft_count: () -> (nat) query;
   /// Get the trait schema (public query)
   get_trait_schema: () -> (TraitSchema) query;
   /// Get the canister's balance of a specific ICRC-1 token.
   get_treasury_balance: (ledger_id: principal) -> (nat);
   get_upcoming_events: (daysAhead: nat) -> (vec ScheduledEvent) query;
   get_upcoming_events_with_races: (daysAhead: nat) ->
    (vec
      record {
        event: ScheduledEvent;
        raceSummary:
         record {
           distances: vec nat;
           terrains: vec Terrain;
           totalParticipants: nat;
           totalRaces: nat;
         };
      }) query;
   /// Handle incoming HTTP requests.
   http_request: (req: HttpRequest) -> (HttpResponse) query;
   /// Handle streaming callbacks for large HTTP responses.
   http_request_streaming_callback: (token: StreamingToken) ->
    (opt StreamingCallbackResponse) query;
   /// Handle incoming HTTP requests that modify state (e.g., POST).
   http_request_update: (req: HttpRequest) -> (HttpResponse);
   icrc120_upgrade_finished: () -> (UpgradeFinishedResult);
   initialize_race_timer: () -> (text);
   /// List all API keys owned by the caller.
   ///    * @returns A list of API key metadata (but not the raw keys).
   list_my_api_keys: () -> (vec ApiKeyMetadata) query;
   process_overdue_timers: () -> (text);
   reattach_races_to_event: (eventId: nat, raceIds: vec nat) -> (text);
   recalculate_bot_stats: () -> (text);
   reset_all_elos: () -> (text);
   /// Reset a bot's racing stats (owner only) - allows re-initialization with correct faction
   /// This is useful after faction system changes or data migrations
   reset_bot_stats: (tokenIndex: nat) -> (Result_1);
   /// Revoke (delete) an API key owned by the caller.
   ///    * @param key_id The ID of the key to revoke.
   ///    * @returns True if the key was found and revoked, false otherwise.
   revoke_my_api_key: (key_id: text) -> ();
   /// Set the EXT NFT canister ID. Only the current owner can call this.
   set_ext_canister: (canister_id: principal) -> (Result_1);
   /// Set the ICP ledger canister ID. Only the current owner can call this.
   set_icp_ledger: (ledger_id: principal) -> (Result_1);
   /// Set a new owner for the canister. Only the current owner can call this.
   set_owner: (new_owner: principal) -> (Result_2);
   transformJwksResponse:
    (record {
       context: blob;
       response: HttpRequestResult;
     }) -> (HttpRequestResult) query;
   trigger_event_creation: () -> (text);
   trigger_race_creation: () -> (text);
   trigger_race_start: (raceId: nat) -> (text);
   trigger_stuck_races: () -> (text);
   /// Upload a batch of pre-computed base stats
   upload_base_stats_batch: (batch:
    vec
     record {
       nat;
       record {
         acceleration: nat;
         faction: text;
         powerCore: nat;
         speed: nat;
         stability: nat;
       };
     }) -> ();
   /// Upload NFT stats in batch (owner only for security)
   /// Stats are stored as raw integer arrays [type_id, body_id, driver_id, ...]
   upload_nft_stats_batch: (batch: vec record {
                                         nat;
                                         NFTStats;
                                       }) -> (Result_1);
   /// Upload trait schema (owner only, done once)
   upload_trait_schema: (schemaData: TraitSchema) -> (Result_1);
   validate_timer_state: () -> (vec text) query;
   /// Withdraw tokens from the canister's treasury to a specified destination.
   withdraw: (ledger_id: principal, amount: nat, destination: Destination) ->
    (Result);
 };
type LeaderboardType = 
 variant {
   AllTime;
   Division: RaceClass;
   Faction: FactionType;
   Monthly: nat;
   Season: nat;
 };
type LeaderboardEntry = 
 record {
   avgPosition: float64;
   bestFinish: nat;
   currentStreak: int;
   lastRaceTime: int;
   owner: principal;
   podiums: nat;
   points: nat;
   previousRank: opt nat;
   races: nat;
   rank: nat;
   tokenIndex: nat;
   totalEarnings: nat;
   trend: TrendDirection;
   winRate: float64;
   wins: nat;
 };
type HttpResponse = 
 record {
   body: blob;
   headers: vec Header;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
   upgrade: opt bool;
 };
type HttpRequestResult = 
 record {
   body: blob;
   headers: vec HttpHeader;
   status: nat;
 };
type HttpRequest = 
 record {
   body: blob;
   certificate_version: opt nat16;
   headers: vec Header;
   method: text;
   url: text;
 };
type HttpHeader = 
 record {
   name: text;
   value: text;
 };
type Header = 
 record {
   text;
   text;
 };
type HashedApiKey = text;
type FactionType = 
 variant {
   Animal;
   Bee;
   Blackhole;
   Box;
   Dead;
   Food;
   Game;
   Golden;
   Industrial;
   Master;
   Murder;
   Ultimate;
   UltimateMaster;
   Wild;
 };
type EventType = 
 variant {
   DailySprint;
   MonthlyCup;
   SpecialEvent: text;
   WeeklyLeague;
 };
type EventStatus = 
 variant {
   Announced;
   Cancelled;
   Completed;
   InProgress;
   RegistrationClosed;
   RegistrationOpen;
 };
type EventMetadata = 
 record {
   description: text;
   divisions: vec RaceClass;
   entryFee: nat;
   maxEntries: nat;
   minEntries: nat;
   name: text;
   pointsMultiplier: float64;
   prizePoolBonus: nat;
 };
type Destination = 
 record {
   owner: principal;
   subaccount: opt Subaccount;
 };
type CancellationResult = 
 record {
   cancelled: vec ActionId;
   errors: vec record {
                 nat;
                 text;
               };
   notFound: vec nat;
 };
type ApiKeyMetadata = 
 record {
   hashed_key: HashedApiKey;
   info: ApiKeyInfo;
 };
type ApiKeyInfo = 
 record {
   created: Time;
   name: text;
   "principal": principal;
   scopes: vec text;
 };
type ActionId = 
 record {
   id: nat;
   time: Time__1;
 };
type ActionFilter = 
 variant {
   All;
   ByActionId: nat;
   ByRetryCount: nat;
   ByTimeRange: record {
                  Time__1;
                  Time__1;
                };
   ByType: text;
 };
type ActionDetail = 
 record {
   ActionId;
   Action;
 };
type Action = 
 record {
   aSync: opt nat;
   actionType: text;
   params: blob;
   retries: nat;
 };
service : (args: opt
                  record {
                    extCanisterId: opt principal;
                    owner: opt principal;
                  }) -> McpServer
