type WorldBuff = 
 record {
   appliedAt: int;
   expiresAt: int;
   stats: vec record {
                text;
                nat;
              };
 };
type UserInventory = 
 record {
   gyroModules: nat;
   owner: principal;
   powerCoreFragments: nat;
   speedChips: nat;
   thrusterKits: nat;
   universalParts: nat;
 };
type UpgradeType = 
 variant {
   Gyro;
   PowerCore;
   Thruster;
   Velocity;
 };
type UpgradeSession = 
 record {
   consecutiveFails: nat;
   costPaid: nat;
   endsAt: int;
   partsUsed: nat;
   paymentMethod: text;
   startedAt: int;
   tokenIndex: nat;
   upgradeType: UpgradeType;
 };
type UpgradeFinishedResult = 
 variant {
   Failed: record {
             nat;
             text;
           };
   InProgress: nat;
   Success: nat;
 };
type TrendDirection = 
 variant {
   Down: nat;
   New;
   Stable;
   Up: nat;
 };
type TreasuryError = 
 variant {
   LedgerTrap: text;
   NotOwner;
   TransferFailed: TransferError;
 };
type TransferError = 
 variant {
   BadBurn: record {min_burn_amount: nat;};
   BadFee: record {expected_fee: nat;};
   CreatedInFuture: record {ledger_time: Timestamp;};
   Duplicate: record {duplicate_of: nat;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: nat;};
   TemporarilyUnavailable;
   TooOld;
 };
type TraitValue = 
 record {
   id: nat;
   name: text;
 };
type TraitSchema = vec Trait;
type Trait = 
 record {
   id: nat;
   name: text;
   values: vec TraitValue;
 };
type Timestamp = nat64;
type TimerId = nat;
type TimerDiagnostics = 
 record {
   currentTime: Time__1;
   lastExecutionDelta: int;
   lockStatus: opt Time__1;
   nextExecutionDelta: opt int;
   overdueActions: nat;
   pendingActions: nat;
   systemTimerStatus: opt TimerId;
   totalActions: nat;
 };
type Time__1 = nat;
type Time = int;
type Terrain = 
 variant {
   MetalRoads;
   ScrapHeaps;
   WastelandSand;
 };
type Subaccount = blob;
type StreamingToken = blob;
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: StreamingCallback;
                              token: StreamingToken;
                            };};
type StreamingCallbackResponse = 
 record {
   body: blob;
   token: opt StreamingToken;
 };
type StreamingCallback = func (StreamingToken) ->
                          (opt StreamingCallbackResponse) query;
type Sponsor = 
 record {
   amount: nat;
   message: opt text;
   sponsor: principal;
   timestamp: int;
 };
type ScheduledEvent = 
 record {
   createdAt: int;
   eventId: nat;
   eventType: EventType;
   metadata: EventMetadata;
   raceIds: vec nat;
   registrationCloses: int;
   registrationOpens: int;
   scheduledTime: int;
   status: EventStatus;
 };
type ScavengingZone = 
 variant {
   AbandonedSettlements;
   DeadMachineFields;
   RepairBay;
   ScrapHeaps;
 };
type ScavengingMission = 
 record {
   durationMinutes: opt nat;
   lastAccumulation: int;
   missionId: nat;
   pendingParts:
    record {
      gyroModules: nat;
      powerCoreFragments: nat;
      speedChips: nat;
      thrusterKits: nat;
      universalParts: nat;
    };
   startTime: int;
   tokenIndex: nat;
   zone: ScavengingZone;
 };
type Result_4 = 
 variant {
   err: TreasuryError;
   ok;
 };
type Result_3 = 
 variant {
   err: text;
   ok;
 };
type Result_2 = 
 variant {
   err: text;
   ok:
    record {
      activeUpgrade: opt UpgradeSession;
      baseStats:
       record {
         acceleration: nat;
         powerCore: nat;
         speed: nat;
         stability: nat;
       };
      currentBattery: nat;
      currentCondition: nat;
      isOwner: bool;
      stats: PokedBotRacingStats;
      upgradeCosts:
       record {
         Gyro: record {
                 icp: nat;
                 parts: nat;
               };
         PowerCore: record {
                      icp: nat;
                      parts: nat;
                    };
         Thruster: record {
                     icp: nat;
                     parts: nat;
                   };
         Velocity: record {
                     icp: nat;
                     parts: nat;
                   };
       };
    };
 };
type Result_1 = 
 variant {
   err: text;
   ok: text;
 };
type Result = 
 variant {
   err: TreasuryError;
   ok: nat;
 };
type ReconstitutionTrace = 
 record {
   actionsRestored: nat;
   errors: vec text;
   migratedFrom: text;
   migratedTo: text;
   timersRestored: nat;
   timestamp: Time__1;
   validationPassed: bool;
 };
type RacingStats = 
 record {
   acceleration: nat;
   powerCore: nat;
   speed: nat;
   stability: nat;
 };
type RaceStatus = 
 variant {
   Cancelled;
   Completed;
   InProgress;
   Upcoming;
 };
type RaceResult = 
 record {
   finalTime: float64;
   nftId: text;
   owner: principal;
   position: nat;
   prizeAmount: nat;
   stats: opt RacingStats;
 };
type RaceEntry = 
 record {
   enteredAt: int;
   entryFee: nat;
   nftId: text;
   owner: principal;
   stats: opt RacingStats;
 };
type RaceClass = 
 variant {
   Elite;
   Junker;
   Raider;
   Scrap;
   SilentKlan;
 };
type Race = 
 record {
   createdAt: int;
   distance: nat;
   duration: nat;
   entries: vec RaceEntry;
   entryDeadline: int;
   entryFee: nat;
   maxEntries: nat;
   minEntries: nat;
   name: text;
   platformBonus: nat;
   platformTax: nat;
   prizePool: nat;
   raceClass: RaceClass;
   raceId: nat;
   results: opt vec RaceResult;
   sponsors: vec Sponsor;
   startTime: int;
   status: RaceStatus;
   terrain: Terrain;
   trackId: nat;
   trackSeed: nat;
 };
type PokedBotRacingStats = 
 record {
   accelerationBonus: nat;
   accelerationUpgrades: nat;
   activatedAt: int;
   activeMission: opt ScavengingMission;
   battery: nat;
   bestHaul: nat;
   condition: nat;
   eloRating: nat;
   experience: nat;
   faction: FactionType;
   factionReputation: nat;
   lastDecayed: int;
   lastDiagnostics: opt int;
   lastMissionRewards:
    opt
     record {
       completedAt: int;
       gyroModules: nat;
       hoursOut: nat;
       powerCoreFragments: nat;
       speedChips: nat;
       thrusterKits: nat;
       totalParts: nat;
       universalParts: nat;
       zone: ScavengingZone;
     };
   lastRaced: opt int;
   lastRecharged: opt int;
   lastRepaired: opt int;
   listedForSale: bool;
   name: opt text;
   overcharge: nat;
   ownerPrincipal: principal;
   places: nat;
   powerCoreBonus: nat;
   powerCoreUpgrades: nat;
   preferredDistance: Distance;
   preferredTerrain: Terrain;
   racesEntered: nat;
   scavengingMissions: nat;
   scavengingReputation: nat;
   shows: nat;
   speedBonus: nat;
   speedUpgrades: nat;
   stabilityBonus: nat;
   stabilityUpgrades: nat;
   tokenIndex: nat;
   totalPartsScavenged: nat;
   totalScrapEarned: nat;
   upgradeEndsAt: opt int;
   wins: nat;
   worldBuff: opt WorldBuff;
 };
type NFTStats = vec nat;
type NFTMetadata = 
 vec record {
       text;
       text;
     };
type McpServer = 
 service {
   /// Admin method to remove a bot from a race (for fixing bugs/errors)
   admin_remove_race_entry: (raceId: nat, tokenIndex: nat) -> (Result_1);
   admin_update_race_min_entries: (raceId: nat, minEntries: nat) -> (text);
   cancel_actions_by_filter: (filter: ActionFilter) -> (CancellationResult);
   cancel_actions_by_ids: (ids: vec nat) -> (CancellationResult);
   cancel_races_by_ids: (raceIds: vec nat) -> (vec record {
                                                     nat;
                                                     text;
                                                   });
   cleanup_duplicate_race_create_timers: () -> (text);
   cleanup_duplicate_recharge_timers: () -> (text);
   clear_reconstitution_traces: () -> ();
   /// * Creates a new API key. This API key is linked to the caller's principal.
   ///    * @param name A human-readable name for the key.
   ///    * @returns The raw, unhashed API key. THIS IS THE ONLY TIME IT WILL BE VISIBLE.
   create_my_api_key: (name: text, scopes: vec text) -> (text);
   /// Test/debug: Get all available tracks
   debug_get_all_tracks: () ->
    (vec
      record {
        description: text;
        laps: nat;
        name: text;
        primaryTerrain: Terrain;
        segmentCount: nat;
        totalDistance: nat;
        trackId: nat;
      }) query;
   /// Test/debug: Simulate a race with specific bots on a specific track
   /// Returns detailed results for balance testing
   debug_simulate_race: (trackId: nat, tokenIndices: vec nat, seed: nat) ->
    (opt
      record {
        analysis:
         record {
           avgTime: float64;
           lastPlaceTime: float64;
           timeSpread: float64;
           winner: nat;
           winnerTime: float64;
         };
        participants:
         vec
          record {
            stats:
             record {
               acceleration: nat;
               powerCore: nat;
               speed: nat;
               stability: nat;
             };
            tokenIndex: nat;
          };
        results:
         vec
          record {
            avgSegmentTime: float64;
            finalTime: float64;
            position: nat;
            tokenIndex: nat;
          };
        track:
         record {
           description: text;
           laps: nat;
           name: text;
           segmentCount: nat;
           totalDistance: nat;
           trackId: nat;
         };
      }) query;
   /// Debug: Test simulate a race with specific bots and track
   /// Returns backend-calculated times for validation
   debug_test_simulation: (tokenIndexes: vec nat, trackId: nat, trackSeed:
    nat) ->
    (opt record {results: vec record {
                                finalTime: float64;
                                tokenIndex: nat;
                              };}) query;
   /// Decode EXT token identifier to get token index (public query)
   decode_token_identifier: (tokenIdentifier: text) -> (nat) query;
   delete_events_and_races: (eventIds: vec nat) -> (text);
   emergency_clear_all_timers: () -> (nat);
   /// Encode token index to EXT token identifier (public query)
   encode_token_identifier: (tokenIndex: nat32) -> (text) query;
   force_finish_race: (raceId: nat) -> (text);
   force_release_lock: () -> (opt Time);
   force_system_timer_cancel: () -> (bool);
   get_actions_by_filter: (filter: ActionFilter) -> (vec ActionDetail) query;
   get_all_scheduled_events: () -> (vec ScheduledEvent) query;
   /// Get all token IDs that have metadata
   get_all_token_ids: () -> (vec nat) query;
   /// Get total count of pre-computed base stats
   get_base_stats_count: () -> (nat) query;
   /// Get public bot profile (stats + career, no sensitive info like battery/condition)
   get_bot_profile: (tokenIndex: nat) ->
    (opt
      record {
        career:
         record {
           podiums: nat;
           racesEntered: nat;
           totalEarnings: nat;
           wins: nat;
         };
        eloRating: nat;
        faction: FactionType;
        isInitialized: bool;
        name: opt text;
        owner: opt principal;
        preferredTerrain: Terrain;
        raceClass: RaceClass;
        stats:
         record {
           acceleration: nat;
           overallRating: nat;
           powerCore: nat;
           speed: nat;
           stability: nat;
         };
        tokenIndex: nat;
      }) query;
   get_bot_race_history: (tokenIndex: nat, limit: nat, afterRaceId:
    opt nat) ->
    (record {
       hasMore: bool;
       nextRaceId: opt nat;
       races:
        vec
         record {
           eventId: nat;
           eventName: text;
           finalTime: opt float64;
           position: nat;
           prizeAmount: nat;
           raceId: nat;
           raceName: text;
           scheduledTime: int;
           totalRacers: nat;
         };
     }) query;
   /// Get all completed races with their results for analysis
   get_completed_races: (limit: nat) ->
    (vec
      record {
        distance: nat;
        entryCount: nat;
        name: text;
        raceClass: RaceClass;
        raceId: nat;
        results:
         opt vec record {
                   finalTime: float64;
                   nftId: text;
                   position: nat;
                 };
        terrain: Terrain;
        trackId: nat;
        trackSeed: nat;
      }) query;
   get_current_periods: () -> (record {
                                 monthId: nat;
                                 seasonId: nat;
                               }) query;
   get_event_details: (eventId: nat) -> (opt ScheduledEvent) query;
   get_event_with_races: (eventId: nat) ->
    (opt
      record {
        event: ScheduledEvent;
        races:
         vec
          record {
            currentEntries: nat;
            distance: nat;
            entryFee: nat;
            maxEntries: nat;
            name: text;
            participantTokens: vec nat;
            raceClass: RaceClass;
            raceId: nat;
            terrain: Terrain;
          };
      }) query;
   /// Get the currently configured EXT NFT canister ID.
   get_ext_canister: () -> (principal) query;
   /// Get the currently configured ICP ledger canister ID.
   get_icp_ledger: () -> (opt principal) query;
   get_latest_reconstitution_trace: () -> (opt ReconstitutionTrace) query;
   get_leaderboard: (lbType: LeaderboardType, limit: nat) ->
    (vec LeaderboardEntry) query;
   get_my_ranking: (lbType: LeaderboardType, tokenIndex: nat) ->
    (opt LeaderboardEntry) query;
   /// Get decoded metadata for a specific NFT (public query)
   get_nft_metadata: (tokenId: nat) -> (opt NFTMetadata) query;
   /// Get decoded metadata for multiple NFTs in one call (public query)
   get_nft_metadata_batch: (tokenIds: vec nat) ->
    (vec record {
           nat;
           opt NFTMetadata;
         }) query;
   /// Get metadata by EXT token identifier (public query)
   get_nft_metadata_by_identifier: (tokenIdentifier: text) ->
    (opt NFTMetadata) query;
   /// Get paginated NFT metadata (decoded, public query)
   get_nft_metadata_page: (offset: nat, limit: nat) ->
    (vec record {
           nat;
           NFTMetadata;
         }) query;
   /// Get raw stats for a specific NFT (returns integer array)
   get_nft_stats: (tokenId: nat) -> (opt NFTStats) query;
   /// Get raw stats by EXT token identifier (public query)
   get_nft_stats_by_identifier: (tokenIdentifier: text) ->
    (opt NFTStats) query;
   /// Get a decoded trait value by trait name (for display)
   get_nft_trait: (tokenId: nat, traitName: text) -> (opt text) query;
   /// Get a specific trait value ID by trait index (for calculations)
   get_nft_trait_value: (tokenId: nat, traitIndex: nat) -> (opt nat) query;
   /// Get the current owner of the canister.
   get_owner: () -> (principal) query;
   get_past_events: (offset: nat, limit: nat) -> (vec ScheduledEvent) query;
   get_race_by_id: (raceId: nat) -> (opt Race) query;
   get_reconstitution_traces: () -> (vec ReconstitutionTrace) query;
   get_timer_diagnostics: () -> (TimerDiagnostics) query;
   /// Get total count of NFTs with metadata stored
   get_total_nft_count: () -> (nat) query;
   /// Get the trait schema (public query)
   get_trait_schema: () -> (TraitSchema) query;
   /// Get the canister's balance of a specific ICRC-1 token.
   get_treasury_balance: (ledger_id: principal) -> (nat);
   get_upcoming_events: (daysAhead: nat) -> (vec ScheduledEvent) query;
   get_upcoming_events_with_races: (daysAhead: nat) ->
    (vec
      record {
        event: ScheduledEvent;
        raceSummary:
         record {
           distances: vec nat;
           terrains: vec Terrain;
           totalParticipants: nat;
           totalRaces: nat;
         };
      }) query;
   /// Handle incoming HTTP requests.
   http_request: (req: HttpRequest) -> (HttpResponse) query;
   /// Handle streaming callbacks for large HTTP responses.
   http_request_streaming_callback: (token: StreamingToken) ->
    (opt StreamingCallbackResponse) query;
   /// Handle incoming HTTP requests that modify state (e.g., POST).
   http_request_update: (req: HttpRequest) -> (HttpResponse);
   icrc120_upgrade_finished: () -> (UpgradeFinishedResult);
   /// List all API keys owned by the caller.
   ///    * @returns A list of API key metadata (but not the raw keys).
   list_my_api_keys: () -> (vec ApiKeyMetadata) query;
   query_races: (filters:
    record {
      afterRaceId: opt nat;
      eligibleForCaller: opt record {
                               caller: principal;
                               eligibleOnly: bool;
                             };
      hasMinimumEntries: opt bool;
      limit: nat;
      maxEntries: opt nat;
      maxPrizePool: opt nat;
      minEntries: opt nat;
      minPrizePool: opt nat;
      participantNftId: opt text;
      participantPrincipal: opt principal;
      raceClass: opt RaceClass;
      startTimeFrom: opt int;
      startTimeTo: opt int;
      status: opt RaceStatus;
      terrain: opt Terrain;
    }) ->
    (record {
       hasMore: bool;
       nextRaceId: opt nat;
       races: vec Race;
       totalMatching: nat;
     }) query;
   recalculate_bot_stats: () -> (text);
   /// Revoke (delete) an API key owned by the caller.
   ///    * @param key_id The ID of the key to revoke.
   ///    * @returns True if the key was found and revoked, false otherwise.
   revoke_my_api_key: (key_id: text) -> ();
   /// Set the EXT NFT canister ID. Only the current owner can call this.
   set_ext_canister: (canister_id: principal) -> (Result_3);
   /// Set the ICP ledger canister ID. Only the current owner can call this.
   set_icp_ledger: (ledger_id: principal) -> (Result_3);
   /// Set a new owner for the canister. Only the current owner can call this.
   set_owner: (new_owner: principal) -> (Result_4);
   transformJwksResponse:
    (record {
       context: blob;
       response: HttpRequestResult;
     }) -> (HttpRequestResult) query;
   trigger_race_finish: (raceId: nat) -> (text);
   trigger_race_start: (raceId: nat) -> (text);
   /// Upload a batch of pre-computed base stats
   upload_base_stats_batch: (batch:
    vec
     record {
       nat;
       record {
         acceleration: nat;
         faction: text;
         powerCore: nat;
         speed: nat;
         stability: nat;
       };
     }) -> ();
   /// Upload NFT stats in batch (owner only for security)
   /// Stats are stored as raw integer arrays [type_id, body_id, driver_id, ...]
   upload_nft_stats_batch: (batch: vec record {
                                         nat;
                                         NFTStats;
                                       }) -> (Result_3);
   /// Upload trait schema (owner only, done once)
   upload_trait_schema: (schemaData: TraitSchema) -> (Result_3);
   validate_timer_state: () -> (vec text) query;
   /// Browse marketplace listings with filtering and pagination
   web_browse_marketplace: (after: opt nat, minRating: opt nat, maxPrice:
    opt float64, faction: opt text, sortBy: opt text, sortDesc: opt bool,
    limit: opt nat) ->
    (record {
       hasMore: bool;
       listings:
        vec
         record {
           baseAcceleration: nat;
           basePowerCore: nat;
           baseSpeed: nat;
           baseStability: nat;
           faction: opt text;
           imageUrl: text;
           isInitialized: bool;
           overallRating: nat;
           price: float64;
           racesEntered: nat;
           tokenIndex: nat;
           winRate: float64;
           wins: nat;
         };
     });
   /// Cancel an in-progress upgrade and receive a full refund
   web_cancel_upgrade: (tokenIndex: nat) -> (Result_1);
   /// Complete a scavenging mission and collect rewards (web method)
   web_complete_scavenging: (tokenIndex: nat) -> (Result_1);
   /// Enter a race (with ICRC-2 payment for entry fee)
   web_enter_race: (raceId: nat, tokenIndex: nat) -> (Result_1);
   /// Get detailed stats for a specific bot
   web_get_bot_details: (tokenIndex: nat) -> (Result_2);
   /// Get bot details for multiple token indices (query call for performance)
   web_get_bot_details_batch: (tokenIndices: vec nat) ->
    (vec
      record {
        baseAcceleration: nat;
        basePowerCore: nat;
        baseSpeed: nat;
        baseStability: nat;
        faction: opt text;
        imageUrl: text;
        isInitialized: bool;
        overallRating: nat;
        racesEntered: nat;
        tokenIndex: nat;
        winRate: float64;
        wins: nat;
      }) query;
   /// Get faction synergy bonuses for the caller's collection
   web_get_collection_bonuses: () ->
    (record {
       costMultipliers:
        record {
          rechargeCooldown: float64;
          repair: float64;
          upgrade: float64;
        };
       drainMultipliers: record {scavenging: float64;};
       statBonuses:
        record {
          acceleration: int;
          powerCore: int;
          speed: int;
          stability: int;
        };
       yieldMultipliers: record {
                           parts: float64;
                           prizes: float64;
                         };
     }) query;
   /// Get user's parts inventory
   web_get_user_inventory: () -> (UserInventory) query;
   /// Initialize a bot for racing (web equivalent of garage_initialize_pokedbot)
   web_initialize_bot: (tokenIndex: nat, name: opt text) -> (Result_1);
   /// List all PokedBots owned by the caller in their wallet
   web_list_my_bots: () ->
    (vec
      record {
        activeUpgrade: opt UpgradeSession;
        currentOwner: text;
        currentStats:
         opt
          record {
            acceleration: nat;
            powerCore: nat;
            speed: nat;
            stability: nat;
          };
        eligibleRaces:
         vec
          record {
            entryDeadline: int;
            entryFee: nat;
            name: text;
            raceId: nat;
            startTime: int;
            terrain: Terrain;
          };
        isInitialized: bool;
        maxStats:
         opt
          record {
            acceleration: nat;
            powerCore: nat;
            speed: nat;
            stability: nat;
          };
        name: opt text;
        stats: opt PokedBotRacingStats;
        tokenIndex: nat;
        upcomingRaces:
         vec
          record {
            entryDeadline: int;
            entryFee: nat;
            name: text;
            raceId: nat;
            startTime: int;
            terrain: Terrain;
          };
        upgradeCostsV2:
         opt
          record {
            acceleration: record {
                            costE8s: nat;
                            successRate: float64;
                          };
            pityCounter: nat;
            powerCore: record {
                         costE8s: nat;
                         successRate: float64;
                       };
            speed: record {
                     costE8s: nat;
                     successRate: float64;
                   };
            stability: record {
                         costE8s: nat;
                         successRate: float64;
                       };
          };
      });
   /// List all PokedBots registered in the garage by the caller (QUERY - no EXT canister call)
   /// Returns only bots that have been initialized for racing
   /// Frontend should query EXT canister separately to show unregistered bots
   web_list_my_registered_bots: () ->
    (vec
      record {
        activeUpgrade: opt UpgradeSession;
        currentStats:
         record {
           acceleration: nat;
           powerCore: nat;
           speed: nat;
           stability: nat;
         };
        eligibleRaces:
         vec
          record {
            entryDeadline: int;
            entryFee: nat;
            name: text;
            raceId: nat;
            startTime: int;
            terrain: Terrain;
          };
        maxStats:
         record {
           acceleration: nat;
           powerCore: nat;
           speed: nat;
           stability: nat;
         };
        name: opt text;
        stats: PokedBotRacingStats;
        tokenIndex: nat;
        upcomingRaces:
         vec
          record {
            entryDeadline: int;
            entryFee: nat;
            name: text;
            raceId: nat;
            startTime: int;
            terrain: Terrain;
          };
        upgradeCostsV2:
         record {
           acceleration: record {
                           costE8s: nat;
                           successRate: float64;
                         };
           pityCounter: nat;
           powerCore: record {
                        costE8s: nat;
                        successRate: float64;
                      };
           speed: record {
                    costE8s: nat;
                    successRate: float64;
                  };
           stability: record {
                        costE8s: nat;
                        successRate: float64;
                      };
         };
      }) query;
   /// Recharge a bot's battery (0.1 ICP + fee via ICRC-2)
   web_recharge_bot: (tokenIndex: nat) -> (Result_1);
   /// Repair a bot to restore condition (0.05 ICP + fee via ICRC-2)
   web_repair_bot: (tokenIndex: nat) -> (Result_1);
   /// Start a scavenging mission (web method)
   web_start_scavenging: (tokenIndex: nat, zone: text, durationMinutes:
    opt nat) -> (Result_1);
   /// Upgrade a bot stat (via ICRC-2 payment or parts)
   web_upgrade_bot: (tokenIndex: nat, upgradeType: UpgradeType,
    paymentMethod: variant {
                     icp;
                     parts;
                   }) -> (Result_1);
   /// Withdraw tokens from the canister's treasury to a specified destination.
   withdraw: (ledger_id: principal, amount: nat, destination: Destination) ->
    (Result);
 };
type LeaderboardType = 
 variant {
   AllTime;
   Division: RaceClass;
   Faction: FactionType;
   Monthly: nat;
   Season: nat;
 };
type LeaderboardEntry = 
 record {
   avgPosition: float64;
   bestFinish: nat;
   currentStreak: int;
   lastRaceTime: int;
   owner: principal;
   podiums: nat;
   points: nat;
   previousRank: opt nat;
   races: nat;
   rank: nat;
   tokenIndex: nat;
   totalEarnings: nat;
   trend: TrendDirection;
   winRate: float64;
   wins: nat;
 };
type HttpResponse = 
 record {
   body: blob;
   headers: vec Header;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
   upgrade: opt bool;
 };
type HttpRequestResult = 
 record {
   body: blob;
   headers: vec HttpHeader;
   status: nat;
 };
type HttpRequest = 
 record {
   body: blob;
   certificate_version: opt nat16;
   headers: vec Header;
   method: text;
   url: text;
 };
type HttpHeader = 
 record {
   name: text;
   value: text;
 };
type Header = 
 record {
   text;
   text;
 };
type HashedApiKey = text;
type FactionType = 
 variant {
   Animal;
   Bee;
   Blackhole;
   Box;
   Dead;
   Food;
   Game;
   Golden;
   Industrial;
   Master;
   Murder;
   Ultimate;
   UltimateMaster;
   Wild;
 };
type EventType = 
 variant {
   DailySprint;
   MonthlyCup;
   SpecialEvent: text;
   WeeklyLeague;
 };
type EventStatus = 
 variant {
   Announced;
   Cancelled;
   Completed;
   InProgress;
   RegistrationClosed;
   RegistrationOpen;
 };
type EventMetadata = 
 record {
   description: text;
   divisions: vec RaceClass;
   entryFee: nat;
   maxEntries: nat;
   minEntries: nat;
   name: text;
   pointsMultiplier: float64;
   prizePoolBonus: nat;
 };
type Distance = 
 variant {
   LongTrek;
   MediumHaul;
   ShortSprint;
 };
type Destination = 
 record {
   owner: principal;
   subaccount: opt Subaccount;
 };
type CancellationResult = 
 record {
   cancelled: vec ActionId;
   errors: vec record {
                 nat;
                 text;
               };
   notFound: vec nat;
 };
type ApiKeyMetadata = 
 record {
   hashed_key: HashedApiKey;
   info: ApiKeyInfo;
 };
type ApiKeyInfo = 
 record {
   created: Time;
   name: text;
   "principal": principal;
   scopes: vec text;
 };
type ActionId = 
 record {
   id: nat;
   time: Time__1;
 };
type ActionFilter = 
 variant {
   All;
   ByActionId: nat;
   ByRetryCount: nat;
   ByTimeRange: record {
                  Time__1;
                  Time__1;
                };
   ByType: text;
 };
type ActionDetail = 
 record {
   ActionId;
   Action;
 };
type Action = 
 record {
   aSync: opt nat;
   actionType: text;
   params: blob;
   retries: nat;
 };
service : (args: opt
                  record {
                    extCanisterId: opt principal;
                    owner: opt principal;
                  }) -> McpServer
