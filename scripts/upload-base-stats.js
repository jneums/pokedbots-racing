#!/usr/bin/env node

/**
 * Script to upload pre-computed base stats to the canister in chunks
 * This handles the precomputed-stats.json file generated by generate-stats.js
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const { HttpAgent, Actor } = require('@icp-sdk/core/agent');
const { Ed25519KeyIdentity } = require('@icp-sdk/core/identity');
const { Secp256k1KeyIdentity } = require('@icp-sdk/core/identity/secp256k1');
const { execSync } = require('child_process');
const pemfile = require('pem-file');

// Configuration
const CHUNK_SIZE = 50; // Number of stats to upload per batch
const STATS_FILE = path.join(__dirname, '../data/precomputed-stats.json');

// Parse command line arguments
const args = process.argv.slice(2);
const networkArgIndex = args.indexOf('--network');
const NETWORK = networkArgIndex >= 0 && args[networkArgIndex + 1] 
  ? args[networkArgIndex + 1] 
  : process.env.DFX_NETWORK || 'local';
  
console.log(`Network: ${NETWORK}`);

/**
 * Load DFX identity from filesystem
 */
function loadDfxIdentity(identityName) {
  const homeDir = os.homedir();
  const identityDir = path.join(homeDir, '.config', 'dfx', 'identity', identityName);
  const pemPath = path.join(identityDir, 'identity.pem');
  
  if (!fs.existsSync(pemPath)) {
    throw new Error(`Could not find identity.pem in ${identityDir}`);
  }
  
  const pemContent = fs.readFileSync(pemPath, 'utf-8');
  const pemBuffer = Buffer.from(pemContent);
  const rawKey = pemfile.decode(pemBuffer);
  
  if (pemContent.includes('EC PRIVATE KEY')) {
    // Secp256k1 key
    if (rawKey.length !== 118) {
      throw new Error(`Invalid Secp256k1 key format: expecting byte length 118 but got ${rawKey.length}`);
    }
    const secretKeySlice = rawKey.subarray(7, 39);
    const secretKeyUint8Array = new Uint8Array(secretKeySlice);
    return Secp256k1KeyIdentity.fromSecretKey(secretKeyUint8Array);
  }
  
  // Ed25519 key
  if (rawKey.length !== 85) {
    throw new Error(`Invalid Ed25519 key format: expecting byte length 85 but got ${rawKey.length}`);
  }
  const secretKey = rawKey.subarray(16, 48);
  const secretKeyUint8Array = new Uint8Array(secretKey);
  return Ed25519KeyIdentity.fromSecretKey(secretKeyUint8Array);
}

/**
 * Get current DFX identity name
 */
function getCurrentIdentityName() {
  return execSync('dfx identity whoami').toString().trim();
}

// Get canister ID and idlFactory
function getCanisterInfo() {
  const isLocal = NETWORK === 'local';
  
  let canisterId;
  if (process.env.CANISTER_ID) {
    canisterId = process.env.CANISTER_ID;
  } else {
    // Try to read from canister_ids.json first (for IC)
    const rootCanisterIdsPath = path.join(__dirname, '../canister_ids.json');
    if (!isLocal && fs.existsSync(rootCanisterIdsPath)) {
      const canisterIds = JSON.parse(fs.readFileSync(rootCanisterIdsPath, 'utf8'));
      canisterId = canisterIds.pokedbots_racing.ic;
    } else {
      // Fall back to .dfx/local/canister_ids.json for local
      const localCanisterIdsPath = path.join(__dirname, '../.dfx/local/canister_ids.json');
      const canisterIds = JSON.parse(fs.readFileSync(localCanisterIdsPath, 'utf8'));
      canisterId = canisterIds.pokedbots_racing.local;
    }
  }
  
  // Import the idlFactory from the generated service file
  const didPath = isLocal 
    ? '../.dfx/local/canisters/pokedbots_racing/service.did.js'
    : '../.dfx/ic/canisters/pokedbots_racing/service.did.js';
  const { idlFactory } = require(didPath);
  
  return { canisterId, idlFactory };
}

// Create agent based on network with DFX identity
async function createAgentForNetwork() {
  const isLocal = NETWORK === 'local';
  const host = isLocal ? 'http://127.0.0.1:4943' : 'https://ic0.app';
  
  // Load the current DFX identity
  const identityName = getCurrentIdentityName();
  console.log(`Using DFX identity: ${identityName}`);
  const identity = loadDfxIdentity(identityName);
  
  // Suppress verbose logging from the agent
  const originalLog = console.log;
  const originalError = console.error;
  console.log = () => {};
  console.error = () => {};
  
  const agent = new HttpAgent({ host, identity });
  
  // Fetch root key for local development
  if (isLocal) {
    await agent.fetchRootKey();
  }
  
  // Restore console
  console.log = originalLog;
  console.error = originalError;
  
  return agent;
}

// Parse the precomputed-stats.json file
function parseStatsFile(filePath) {
  console.log('Reading precomputed stats file...');
  const rawData = fs.readFileSync(filePath, 'utf8');
  const data = JSON.parse(rawData);
  
  if (!data.stats || !Array.isArray(data.stats)) {
    throw new Error('Expected precomputed-stats.json to have a "stats" array');
  }
  
  console.log(`Loaded ${data.stats.length} precomputed stats`);
  
  return data.stats;
}

// Convert to canister format
function convertToCanisterFormat(stats) {
  return stats.map(stat => {
    return [
      BigInt(stat.tokenId),
      {
        speed: BigInt(stat.speed),
        powerCore: BigInt(stat.powerCore),
        acceleration: BigInt(stat.acceleration),
        stability: BigInt(stat.stability),
        faction: stat.faction
      }
    ];
  });
}

// Split data into chunks
function chunkArray(array, size) {
  const chunks = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}

// Upload a single chunk
async function uploadChunk(actor, chunk, chunkIndex, totalChunks) {
  process.stdout.write(`Uploading chunk ${chunkIndex + 1}/${totalChunks} (${chunk.length} stats)...`);
  
  try {
    // Temporarily suppress console output during upload
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;
    console.log = () => {};
    console.error = () => {};
    console.warn = () => {};
    
    await actor.upload_base_stats_batch(chunk);
    
    // Restore console
    console.log = originalLog;
    console.error = originalError;
    console.warn = originalWarn;
    
    process.stdout.write(' ✓\n');
    return true;
  } catch (error) {
    process.stdout.write(' ✗\n');
    console.error(`  Error: ${error.message}`);
    return false;
  }
}

// Main upload function
async function uploadStats() {
  try {
    console.log('=== Pre-computed Base Stats Upload Script ===\n');
    
    // Get canister info
    const { canisterId, idlFactory } = getCanisterInfo();
    console.log(`Using canister ID: ${canisterId}\n`);
    
    // Load and parse data
    const stats = parseStatsFile(STATS_FILE);
    
    // Create agent and actor
    console.log(`Connecting to canister on ${NETWORK} network...`);
    const agent = await createAgentForNetwork();
    const actor = Actor.createActor(idlFactory, {
      agent,
      canisterId,
    });
    
    // Convert to canister format
    console.log('--- Converting Stats ---');
    const canisterData = convertToCanisterFormat(stats);
    
    // Create chunks
    const chunks = chunkArray(canisterData, CHUNK_SIZE);
    console.log(`Split data into ${chunks.length} chunks of ~${CHUNK_SIZE} stats each\n`);
    
    // Upload chunks sequentially
    console.log('--- Uploading Stats ---');
    let successCount = 0;
    let failCount = 0;
    
    for (let i = 0; i < chunks.length; i++) {
      const success = await uploadChunk(actor, chunks[i], i, chunks.length);
      if (success) {
        successCount++;
      } else {
        failCount++;
      }
      
      // Add a small delay between chunks
      if (i < chunks.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    // Summary
    console.log('\n=== Upload Summary ===');
    console.log(`Total stats: ${stats.length}`);
    console.log(`Successful chunks: ${successCount}/${chunks.length}`);
    console.log(`Failed chunks: ${failCount}/${chunks.length}`);
    
    if (failCount === 0) {
      console.log('\n✓ All stats uploaded successfully!');
      
      // Verify upload
      console.log('\nVerifying upload...');
      const totalCount = await actor.get_base_stats_count();
      console.log(`Total precomputed stats in canister: ${totalCount}`);
      
      // Test a sample
      console.log('\nTesting sample stat (token 4885)...');
      const sample = await actor.get_base_stat(4885n);
      if (sample) {
        console.log('Sample:', sample);
      } else {
        console.log('Sample not found');
      }
    } else {
      console.log('\n⚠ Some chunks failed to upload. Please review errors above.');
      process.exit(1);
    }
    
  } catch (error) {
    console.error('\n✗ Upload failed:', error);
    process.exit(1);
  }
}

// Run the script
if (require.main === module) {
  uploadStats().catch(console.error);
}

module.exports = { uploadStats };
